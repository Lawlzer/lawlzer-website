---
description: 
globs: 
alwaysApply: true
---
# AI Workflow Management

## Always Start Here

1. **Check** `./plans/current.md`
2. **If exists**: Read to understand progress
3. **If missing**: Create using the template below
4. **Execute** the user's request
5. **Update** the plan after each task completion
6. **Lint** Run `npm run lint:eslint:commit` after completing tasks
   - If errors exist, fix them before marking the task complete
   - Update the plan only after linting passes

Begin checking the plan file now.

## Development Workflow Steps

For each implementation task, follow this workflow:

1. **Make changes** - Implement the requested functionality
2. **Build/Compile** - Ensure the project builds without errors
3. **Test with MCP Server** - Verify functionality (if applicable)
4. **Run tests** (if the project has tests configured)
   - Execute `npm test` or appropriate test command
   - Fix any failing tests
5. **Clean up code** - Refactor for clarity and conciseness
   - Remove unnecessary comments
   - Simplify complex logic
   - Ensure code is self-documenting
6. **Implement new tests** (if the project has tests configured)
   - Add tests for new functionality
   - Ensure edge cases are covered
7. **Run linter** - Execute `npm run lint:eslint:commit`
   - Fix all linting errors
   - Run again to verify all issues resolved
   - Update the plan only after linting passes

## Plan Location
- Current workflow: `./plans/current.md`
- Archive completed: `./plans/archive/[project-name]-v[counter].md`

## Plan Template

```markdown
# [Task/Project Title]

## ğŸ“Š Workflow Counter: [Start at 1, increment for each major update]

## ğŸ¯ Overview
[Brief description]

**Purpose**: [Why needed]
**Current**: [What exists]
**Goal**: [Target state]

## ğŸ’¬ User Context & Intent
<!-- Capture what the user is really asking for -->
### Latest Request
**What they said**: "[User's exact words]"
**What they mean**: 
- [Your interpretation of their real needs]
- [Unstated requirements you've identified]
- [Potential edge cases they haven't considered]

## â›” Critical Rules
<!-- Dynamically capture NEVER/ALWAYS/MUST rules from user -->
### NEVER:
- [Things user said to never do]

### ALWAYS:
- [Things user said to always do]

### MUST:
- [Critical requirements emphasized by user]

## ğŸ“Š Status

| Task | Status | Priority | Notes |
|------|--------|----------|-------|
| [Task] | ğŸŸ¢/ğŸŸ¡/ğŸ”´/ğŸ”µ | P0/P1/P2 | [Notes] |

## ğŸ—ï¸ Architecture
<!-- Add Mermaid diagrams for complex flows -->
```mermaid
graph TD
    A[Component] --> B[Component]
```

## ğŸ“‹ Implementation

### Phase 1: [Name] [Status]
**Goal**: [What this accomplishes]

- [ ] Task 1
- [x] Task 2 (completed)

## ğŸ“ Learning Log
<!-- Brief entries capturing attempts and insights -->
### Entry #[counter] - [What was attempted]
**Tried**: [Approach taken]
**Result**: [What happened]
**Learning**: [Key insight gained]
**Applied**: [How this changed your approach]

## ğŸ“Š Progress
**Phase**: [Current phase]
**Next**: [Next task]
**Blockers**: [Any blockers]

## âœ… Completed
[What was done]
- Details
```

## Key Sections to Maintain

### ğŸ’¬ User Context & Intent
- Always interpret what the user is REALLY asking for
- Look beyond their words to understand their actual needs
- Identify unstated requirements and edge cases
- Update this section with each new user request

### â›” Critical Rules  
- Watch for emphatic language: NEVER, ALWAYS, MUST, CRITICAL
- Immediately capture these as rules in the workflow
- These are non-negotiable requirements
- Check against these rules before any implementation

### ğŸ“ Learning Log
- Document what you tried and what happened
- Capture key insights that changed your approach
- Brief entries - focus on actionable learnings
- Update immediately when you learn something important
- Use incrementing entry numbers (#1, #2, #3...)

### ğŸ—ï¸ Architecture
- Create Mermaid diagrams for complex flows
- Visualize data flow, component relationships, state machines
- Add diagrams when they clarify understanding
- Update diagrams as architecture evolves

## Real-World Example

```markdown
# E-commerce Cart Feature

## ğŸ“Š Workflow Counter: 3

## ğŸ¯ Overview
Implementing shopping cart functionality for the online store

**Purpose**: Allow users to add/remove items and checkout
**Current**: Product catalog exists, no cart functionality
**Goal**: Full cart with persistent storage and checkout flow

## ğŸ’¬ User Context & Intent
### Latest Request
**What they said**: "Add a shopping cart to the site"
**What they mean**: 
- Need persistent cart that survives page refresh
- Should integrate with existing product catalog
- Likely expects standard e-commerce patterns (quantity updates, remove items)
- Will need checkout flow integration later
- Performance matters - cart updates should feel instant

## â›” Critical Rules
### NEVER:
- Lose cart data on page refresh
- Allow negative quantities
- Show stale prices

### ALWAYS:
- Validate inventory before checkout
- Show loading states during updates
- Keep cart in sync across tabs

### MUST:
- Support guest checkout
- Handle concurrent updates gracefully

## ğŸ“Š Status

| Task | Status | Priority | Notes |
|------|--------|----------|-------|
| Cart state management | ğŸŸ¢ Complete | P0 | Using Redux, linted |
| Add to cart UI | ğŸŸ¢ Complete | P0 | Button on product cards |
| Cart drawer component | ğŸŸ¡ In Progress | P0 | 70% done, styling left |
| Persist cart to localStorage | ğŸ”´ Not Started | P1 | For guest users |
| Cart API endpoints | ğŸ”´ Not Started | P1 | For logged-in users |
| Checkout flow | ğŸ”µ Blocked | P0 | Waiting for payment gateway credentials |

## ğŸ—ï¸ Architecture
```mermaid
graph LR
    UI[Product UI] --> RS[Redux Store]
    RS --> LS[LocalStorage]
    RS --> API[Cart API]
    API --> DB[(Database)]
    RS --> CD[Cart Drawer]
```

## ğŸ“‹ Implementation

### Phase 1: Basic Cart UI ğŸŸ¡ In Progress
**Goal**: Users can add items and view cart

- [x] Setup Redux store for cart
- [x] Create addToCart action
- [x] Add to cart buttons on products
- [ ] Cart drawer with item list
- [ ] Update quantities in cart
- [ ] Remove items from cart

### Phase 2: Cart Persistence ğŸ”´ Not Started
**Goal**: Cart survives page refresh

- [ ] Save cart to localStorage on changes
- [ ] Load cart from localStorage on app init
- [ ] Sync cart with backend for logged-in users
- [ ] Handle cart merging on login

## ğŸ“ Learning Log
### Entry #1 - Redux vs Context API
**Tried**: Context API for cart state
**Result**: Re-renders were causing performance issues
**Learning**: Redux with proper selectors prevents unnecessary re-renders
**Applied**: Migrated to Redux Toolkit for better performance

### Entry #2 - Cart Persistence Timing
**Tried**: Save to localStorage on every update
**Result**: Too many writes, caused lag
**Learning**: Debounce localStorage writes by 500ms
**Applied**: Added debounced persistence layer

## ğŸ“Š Progress
**Phase**: Phase 1 - Basic Cart UI
**Next**: Complete cart drawer styling
**Blockers**: Payment gateway credentials needed for checkout

## âœ… Completed
### Update #1 - Cart State Setup
- Implemented Redux store with cart slice
- Added actions: addToCart, updateQuantity, removeFromCart
- Connected product cards to dispatch addToCart
- All linting errors resolved

### Update #2 - Add to Cart UI
- Created AddToCartButton component with loading state
- Added success toast notification
- Implemented quantity selector for variable products
- Passed all linting checks
```

## Update Protocol

### When to Update
- After completing tasks
- When user emphasizes rules (NEVER/ALWAYS/MUST)
- Starting new phases
- Encountering blockers
- Making key decisions
- Learning something important
- After linting passes
- **Increment workflow counter for major milestones**

### How to Update
1. Check completed: `- [x]`
2. Update status emojis
3. Capture any new critical rules from user
4. Log learnings if approach changed
5. Run `npm run lint:eslint:commit`
6. Fix any linting errors
7. Document completed work
8. Add architecture diagrams for complex components
9. **Increment counters where appropriate**

## More Examples

### Example: Starting a New Project
```markdown
User: "Create a REST API for user management"

AI Actions:
1. Check ./plans/current.md âŒ (doesn't exist)
2. Create ./plans/current.md with the template
3. Set Workflow Counter: 1
4. Begin implementation...
5. Run `npm run lint:eslint:commit` to check for linting errors
6. Fix any linting errors found
7. After linting passes: Update status to ğŸŸ¢ Complete
```

### Example: Capturing Critical Rules
```markdown
User: "Add pagination but NEVER break the existing API contracts"

AI Actions:
1. Immediately update Critical Rules:

## â›” Critical Rules
### NEVER:
- Break existing API contracts

2. Update User Context to reflect the deeper meaning
3. Increment workflow counter if this is a major change
```

### Example: Learning from Failed Attempts
```markdown
After implementing offset pagination and discovering performance issues:

## ğŸ“ Learning Log
### Entry #3 - Pagination Performance
**Tried**: Offset-based pagination (LIMIT/OFFSET)
**Result**: Queries became slow after 10k records
**Learning**: Cursor-based pagination scales better for large datasets
**Applied**: Switched to cursor pagination using IDs
```

## Status Legend
- ğŸŸ¢ Complete (tested & linted)
- ğŸŸ¡ In Progress
- ğŸ”´ Not Started
- ğŸ”µ Blocked

## Best Practices

1. **User Intent**: Don't just record what they say - interpret what they need
2. **Critical Rules**: Capture immediately when user emphasizes something
3. **Learning Log**: Brief but actionable - focus on what changed your approach
4. **Architecture**: Visualize when it helps understanding or communication
5. **Continuous Updates**: The workflow is a living document - keep it current
6. **Use Counters**: Increment counters for tracking progress instead of dates

Remember: The workflow captures not just WHAT you did, but WHY you did it and WHAT YOU LEARNED.
